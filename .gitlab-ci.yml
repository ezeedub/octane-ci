image: outrigger/gitlab-ci-workspace:stable

services:
  - docker:dind

variables:
  # Ensure fast file system is used for docker:dind
  DOCKER_DRIVER: overlay2
  # PROJECT_NAME is ideally set in the CI/CD variables instead of declared here
  # PROJECT_NAME: PUT_PROJECT_NAME_HERE

  # KUBE_NAMESPACE is ideally set in the CI/CD variables instead of declaed here
  # KUBE_NAMESPACE: PUT_NAMESPACE_HERE

  # CI_REGISTRY_IMAGE isn't used directly to structurally allow for projects with
  # multiple images which may need to be built. However, the majority are
  # expected to only ever need to build one image.
  WEB_IMAGE: ${CI_REGISTRY_IMAGE}/web

stages:
  # tasks are intended for items which are only run manually and don't need
  # a build to succeed in order to be able to execute. The idea is that they
  # are always skipped in any automatic activities but come before a build so
  # that if it fails it doesn't effect the ability to run a task
  - tasks
  - build
  - validate
  - deploy
  - update
  - test

before_script:
  # Dump some debugging so we know what variables and values we have to work with.
  - set
  # Sanity check to make sure the project is configured.
  - ./.gitlab-ci/check-settings.sh
  # Ensure DOCKER_HOST is set in runner.
  - source ./.gitlab-ci/check-docker.sh
  # Define project-specific environment variables.
  - source .env

.deploy_script: &deploy_script
  script:
    # Display versions of docker, etc. Comes from gitlab-ci-workspace container.
    - /versions.sh
    # Create a Docker Registry secret (if it doesn't exist) so we can pull images
    # via imagePullSecrets. This depends on a deploy token having been created
    # with name gitlab-deploy-token. See the note about the special naming at
    # https://gitlab.com/help/user/project/deploy_tokens/index#read-container-registry-images
    - kubectl get secret gitlab-registry-secret || kubectl create secret docker-registry gitlab-registry-secret --docker-server=${CI_REGISTRY} --docker-username=${CI_DEPLOY_USER} --docker-password=${CI_DEPLOY_PASSWORD} --docker-email=${GITLAB_USER_EMAIL}
    # Download chart dependencies.
    - helm dependency build .gitlab-ci/chart
    # Do the deployment and output all the YAML resources deployed for this release.
    - helm version
    # Create env configMap from .env file.
    - kubectl create configmap ${RELEASE_NAME}-${CI_ENVIRONMENT_SLUG}-env-config --from-env-file=.env -o yaml --dry-run > .gitlab-ci/manifests/${RELEASE_NAME}-${CI_ENVIRONMENT_SLUG}-env-config.yaml
    # Create additional values from environment.
    - .gitlab-ci/env-values.sh > .gitlab-ci/env-values.yaml
    # Generate the manifests from the chart templates.
    - helm template -f .gitlab-ci/env-values.yaml --output-dir .gitlab-ci/manifests --name ${RELEASE_NAME} --set nameOverride=${CI_ENVIRONMENT_SLUG} --set image.repository=${WEB_IMAGE} --set image.tag=${CI_COMMIT_SHA} --set env.tier=${PROJECT_TIER} --set build_id="build-${CI_JOB_ID}" --set ingress.url.env=${PROJECT_ENV} --set ingress.url.project=${PROJECT_NAME} --debug .gitlab-ci/chart
    # Remove un-needed mariadb-test pod.
    - rm -f .gitlab-ci/manifests/chart/charts/mariadb/templates/test-runner.yaml
    - rm -f .gitlab-ci/manifests/chart/charts/mariadb/templates/tests.yaml
    # Send helm manifests to kubectl to create/update the pods.
    - kubectl apply --recursive --filename .gitlab-ci/manifests
    # Wait for pods to become available.
    - .gitlab-ci/wait-until-pods-ready.sh ${KUBE_NAMESPACE}
    ##- kubectl rollout status --watch deployment/${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}-${CI_ENVIRONMENT_SLUG}
    ##- kubectl get pods
    # Add any post-deploy commands here, such as flowdock notifications
    # - ./.gitlab-ci/flowdock-notify.sh "Deployment complete for ${CI_COMMIT_TITLE} to ${CI_ENVIRONMENT_URL}"

.cleanup_script: &cleanup_script
  variables:
    # This has to match how things line up in the deploy script
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  script:
    - helm delete --purge ${RELEASE_NAME}
  when: manual

build:
  stage: build
  script:
    # Prime the cache
    ##- ./.gitlab-ci/cache-prime.sh
    # Login so we can push images to the registry
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    # assemble the codebase
    - docker-compose -f .gitlab-ci/build.yml run --rm base ./bin/init.sh
    # bundle it into a docker image
    - cp .gitlab-ci/Dockerfile.web Dockerfile
    # Use previous build as cache for performance.
    - docker build --cache-from ${WEB_IMAGE}:${CI_COMMIT_REF_SLUG} -t ${WEB_IMAGE}:${CI_COMMIT_SHA} .
    # Tag it based on slug (branch name) too which can allow for easier commands
    # of the form "deploy the latest version of BRANCH"
    - docker tag ${WEB_IMAGE}:${CI_COMMIT_SHA} ${WEB_IMAGE}:${CI_COMMIT_REF_SLUG}
    # Push all the plain tags and the qa variants and for cache
    - docker push ${WEB_IMAGE}:${CI_COMMIT_SHA}
    - docker push ${WEB_IMAGE}:${CI_COMMIT_REF_SLUG}
    # - ./.gitlab-ci/flowdock-notify.sh "Build of ${CI_COMMIT_REF_NAME} complete for ${CI_COMMIT_TITLE}"
  cache:
    key: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
    paths:
      - build
      - vendor
      - project/themes/*/node_modules
#  when: manual

validate:
  stage: validate
  variables:
    PROJECT_ENV: dev
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  environment:
    name: ${PROJECT_ENV}
  script:
    - docker-compose -f .gitlab-ci/build.yml run --rm base ./bin/validate
    - docker-compose -f .gitlab-ci/build.yml run --rm base ./bin/test unit
  cache:
    key: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
    paths:
      - build
      - vendor
      - project/themes/*/node_modules
  only:
    - /^master/
#  when: manual

deploy_master:
  stage: deploy
  variables:
    PROJECT_ENV: dev
    PROJECT_TIER: dev
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  <<: *deploy_script
  environment:
    name: ${PROJECT_ENV}
    url: http://www.${PROJECT_ENV}.${PROJECT_NAME}.kube.p2devcloud.com
  only:
    - /^master$/
#  when: manual

update:
  stage: update
  variables:
    PROJECT_ENV: dev
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  environment:
    name: ${PROJECT_ENV}
  script:
    - ./.gitlab-ci/exec-web.sh drush status
    - ./.gitlab-ci/exec-web.sh /var/www/bin/import -y
  only:
    - /^master/
#  when: manual

test:
  stage: test
  variables:
    PROJECT_ENV: dev
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  environment:
    name: ${PROJECT_ENV}
  script:
  # NOTE: This is not working yet.
  # Tests need to run in a build container, not the web container.
    - ./.gitlab-ci/exec-web.sh /var/www/bin/test
  only:
    - /^master/
#  when: manual

install:
  stage: tasks
  variables:
    PROJECT_ENV: dev
    RELEASE_NAME: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
  environment:
    name: ${PROJECT_ENV}
  script:
    - ./.gitlab-ci/exec-web.sh /var/www/bin/install -y
  only:
    - /^master/
  when: manual

clean_up_environment:
  stage: tasks
  <<: *cleanup_script
  environment:
    name: ${PROJECT_ENV}
  only:
    - /^master/
  when: manual

clear_composer_cache:
  stage: tasks
  script:
    - rm -rf vendor/*
    - rm -rf build
    - rm -rf ${THEME_PATH}/node_modules
  environment:
    name: ${PROJECT_ENV}
  cache:
    key: ${PROJECT_NAME}-${CI_COMMIT_REF_SLUG}
    paths:
      - build
      - vendor
      - project/themes/*/node_modules
  only:
    - /^master/
  when: manual
